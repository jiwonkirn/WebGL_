## 그래픽 API 설계

- 즉시(immadiate) 모드 API 사용
- 보류(retain) 모드 API 사용

### 즉시 모드 API

즉시모드 API는 장면 변화 여부레 관계없이 매 프레임마다 전체 장면이 다시 그려진다. 이때 그래픽 라이브러리는 장면에 그려지는 내부 모델에 대한 어떠한 정보도 유지하지 않는다.
이러한 방법은 많은 유연성과 제어권을 부여하지만 어플리케이션의 초기화와 클린업, 장면에 그려질 모델에 대한 정보 추적 비용이 추가된다.

WebGL은 즉시모드 API를 사용한다.

### 보류 모드 API

보류모드 API는 그래픽 라이브러리에 렌더링할 내부 모델과 장면 그래프에 대한 정보를 유지한다. 즉 라이브러리가 어떤 장면을 렌더링할지 결정한다.
이는 완전한 장면을 위한 그리기 명령을 수행하지 않아도 됨을 의미하며 라이브러리가 사용자 대신에 어플리케이션상의 많은 작업을 수행함을 의미한다.

SVG가 보류모드 API를 사용한다.

## 그래픽 장치의 개요

어플리케이션이 3D 그래픽을 표현하려면 로우 레벨 소프트웨어 드라이버를 호출하는 API를 호출해 그래픽 데이터를 버스를 거쳐 그래픽 처리 장치로 전송한다.

```
CPU/Memory -> BUS -> GPU -> Disply

GPU
1. GPU 파이프라인 
2. 텍스쳐 메모리
2. 프레임 버퍼 (Z버퍼, 색상 버퍼, 스텐실 버퍼)
3. 비디오 제너레이터
```

### GPU 

GPU는 화면에 그려지는 그래픽 데이터를 생성하는 역할을 전담하도록 설계된 장치다. **높은 병렬성과 빠른 그래픽 데이터 처리 수행 능력**을 가지고 있다.
보통 파이프라인을 통과해 여러 단계별로 데이터가 이동하는 방식으로 작동한다. GPU 파이프라인에 대응하는 웹지엘 파이프라인을 뒤에서 서술한다.

### 프레임 버퍼

그래픽 데이터가 GPU 파이프라인을 순회할 때 마지막으로 도착하는 곳이 프레임 버퍼다. **프레임 버퍼는 화면에 그려지는 최종 이미지 정보를 담고 있는 메모리**이다.
프레임 버퍼로 이용되는 물리적인 메모리는 GPU와 이격되어 있을 수 있으며 메인 메모리를 사용할 수도 있고 GPU에 부착된 매우 빠른 메모리를 사용할 수도 있으며 별도의 칩으로 분리시키기도 한다.

프레임 버퍼는 아래 세가지 하위 버퍼들로 구성된다.

- 색상 버퍼
- Z 버퍼
- 스텐실 버퍼

#### 색상 버퍼

색상 버퍼는 RGB나 RGBA 포맷으로 표현되는 색상 정보를 담고 있는 스크린상의 각 픽셀 정보를 저장하는 직사각형 형태의 메모리 구조이다. 
하나의 픽셀의 색상 결정에 필요한 비트의 총합을 프레임 버퍼의 색상 깊이라 부른다.

- 픽셀당 16bit: R(5), G(6), B(5)
- 픽셀당 24bit: R(8), G(8), B(8)
- 픽셀당 32bit: R(8), G(8), B(8), A(8)

프레임 버퍼는 보통 알파 채널을 사용하지 않는다. 프레임 버퍼의 알파 채널은 보통 목적지 알파 채널로 해석되며 이는 유입되는 픽셀의 투명도를 표현하는 원본 알파 채널과 구분된다.
예를 들어 투명한 오브젝트릐 잔상 표현에 이용하는 알파 블렌딩은 원본 알파 채널만을 필요로 한다.

#### Z 버퍼

3D 장면에서 특정 오브젝트에 가려진 오브젝트는 색상 버퍼에서 이용되지 않는다. 가려진 오브젝트를 판별하기 위래 그래픽 하드웨어는 깊이 버퍼라 불리는 Z버퍼의 지원을 받는다. 
Z버퍼는 각 픽셀마다 관찰자와 가장 가까운 프리미티브의 거리를 저장한다.

#### 스텐실 버퍼

스텐실 버퍼는 색상 버퍼의 특정 위치에 오브젝트가 그려지는 모양을 조정한다. 대표적으로 그림자를 표현하는데 이용된다.

### 텍스쳐 메모리

텍스쳐를 입힌다는 것은 기하 오브젝트에 이미지를 붙이는 것으로도 생각할 수 있다. 이는 빠르고 효율적으로 접근 가능할 수 있는 것이 좋기 때문에 GPU는 텍스처를 위한 특수한 메모리를 포함한다.

### 비디오 컨트롤러(비디오 제너레이터)

비디오 컨트롤러는 색상 버퍼를 라인 단위로 일정 주기로 훑으며 화면을 갱신한다. (ex. 60Hz 주사율)
